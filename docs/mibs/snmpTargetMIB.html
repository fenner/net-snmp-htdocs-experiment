---
section: documentation
---
<!-- CONTENT START -->
<h2>INTRODUCTION</h2>
<ul>
<p>
This is a summary of information regarding objects below the <b>snmpTargetMIB</b>
MIB object, which is defined within the <b>SNMP-TARGET-MIB</b> MIB
document as <b>.1.3.6.1.6.3.12</b>.
</p>
</ul>
<h2>TABLE OF CONTENTS</h2>
<ul>
<h3><a href="#objects_Current">Current Objects</a></h3>
<ul>
<li><a href="#scalar_current">Scalars</a></li>
  <li><a href="#snmpTargetAddrTable">snmpTargetAddrTable</a></li>
  <li><a href="#snmpTargetParamsTable">snmpTargetParamsTable</a></li>
</ul>
<h3><a href="#objects_Deprecated">Deprecated Objects</a></h3>
<ul>
<li><a href="#scalar_notcurrent">Deprecated Scalars</a></li>
</ul>
<h3><a href="#notifications">Notifications</a></h3>
<h3><a href="#textconventions">Textual Conventions</a></h3>
<h3><a href="#treeview">Tree-based view</a></h3>
</ul>
<a name="objects_Current" />
<a name="scalar_current" />
<h2>SCALAR OBJECTS</h2>
<ul>
<table>
<tr><th>Name</th><th>Type</th><th>Access</th><th>OID</th><th>Description</th></tr>
  <tr>
  <td>
<a name="snmpTargetSpinLock" />
1
<br /><b>snmpTargetSpinLock</b>

</td><td>
  INTEGER
      <br />Legal values:
        0 .. 2147483647
 <br>
 <a href="#TestAndIncr">TestAndIncr</a>

  </td><td>ReadWrite</td>
    <td>.1.3.6.1.6.3.12.1.1</td>
<td>
<p>
Note: this object is based on the <a href="#TestAndIncr"> TestAndIncr TEXTUAL-CONVENTION</a>.
</p>
<pre>
This object is used to facilitate modification of table
entries in the SNMP-TARGET-MIB module by multiple
managers.  In particular, it is useful when modifying
the value of the snmpTargetAddrTagList object.

The procedure for modifying the snmpTargetAddrTagList
object is as follows:

    1.  Retrieve the value of snmpTargetSpinLock and
        of snmpTargetAddrTagList.

    2.  Generate a new value for snmpTargetAddrTagList.

    3.  Set the value of snmpTargetSpinLock to the
        retrieved value, and the value of
        snmpTargetAddrTagList to the new value.  If
        the set fails for the snmpTargetSpinLock
        object, go back to step 1.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="snmpUnavailableContexts" />
4
<br /><b>snmpUnavailableContexts</b>

</td><td>
  COUNTER

  </td><td>ReadOnly</td>
    <td>.1.3.6.1.6.3.12.1.4</td>
<td>
<pre>
The total number of packets received by the SNMP
engine which were dropped because the context
contained in the message was unavailable.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="snmpUnknownContexts" />
5
<br /><b>snmpUnknownContexts</b>

</td><td>
  COUNTER

  </td><td>ReadOnly</td>
    <td>.1.3.6.1.6.3.12.1.5</td>
<td>
<pre>
The total number of packets received by the SNMP
engine which were dropped because the context
contained in the message was unknown.
</pre>
</td>
  </tr>
</table>
</ul>

<h2>TABLE OBJECTS</h2>
<a name="snmpTargetAddrTable" /><h3>Table snmpTargetAddrTable</h3>
<ul>
  <table>
  <tr><td class="label">Table Name</td><td>snmpTargetAddrTable</td></tr>
  <tr><td class="label">In MIB</td><td>SNMP-TARGET-MIB</td></tr>
  <tr><td class="label">Registered at OID</td><td>.1.3.6.1.6.3.12.1.2</td></tr>
  <tr><td class="label">Table Description</td>
<td>
<pre>
A table of transport addresses to be used in the generation
of SNMP messages.
</pre>
</td>
</tr>
<tr><td class="label"><a name="snmpTargetAddrEntry" />Row Description</td>
<td>
<pre>
A transport address to be used in the generation
of SNMP operations.

Entries in the snmpTargetAddrTable are created and
deleted using the snmpTargetAddrRowStatus object.
</pre>
</td>
</tr>
  </table>

  <h4>snmpTargetAddrTable Indexes:</h4>

<table>
<tr class="label"><th>Name</th><th>Type</th><th>Access</th><th>Description</th></tr>
  <tr>
  <td>
<a name="snmpTargetAddrName" />
1
<br /><b>snmpTargetAddrName</b>

</td><td>
  OCTETSTR
      <br />Legal Lengths:
        1 .. 32
 <br>
 <a href="#SnmpAdminString">SnmpAdminString</a>

  </td><td>NoAccess</td>
<td>
<p>
Note: this object is based on the <a href="#SnmpAdminString"> SnmpAdminString TEXTUAL-CONVENTION</a>.
</p>
<pre>
The locally arbitrary, but unique identifier associated
with this snmpTargetAddrEntry.
</pre>
</td>
  </tr>
</table>

  <h4>Other snmpTargetAddrTable Columns:</h4>
<table>
<tr class="label"><th>Name</th><th>Type</th><th>Access</th><th>Description</th></tr>
  <tr>
  <td>
<a name="snmpTargetAddrTDomain" />
2
<br /><b>snmpTargetAddrTDomain</b>

</td><td>
  OBJECTID
 <br>
 <a href="#TDomain">TDomain</a>

  </td><td>Create</td>
<td>
<p>
Note: this object is based on the <a href="#TDomain"> TDomain TEXTUAL-CONVENTION</a>.
</p>
<pre>
This object indicates the transport type of the address
contained in the snmpTargetAddrTAddress object.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="snmpTargetAddrTAddress" />
3
<br /><b>snmpTargetAddrTAddress</b>

</td><td>
  OCTETSTR
      <br />Legal Lengths:
        1 .. 255
 <br>
 <a href="#TAddress">TAddress</a>

  </td><td>Create</td>
<td>
<p>
Note: this object is based on the <a href="#TAddress"> TAddress TEXTUAL-CONVENTION</a>.
</p>
<pre>
This object contains a transport address.  The format of
this address depends on the value of the
snmpTargetAddrTDomain object.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="snmpTargetAddrTimeout" />
4
<br /><b>snmpTargetAddrTimeout</b>

</td><td>
  INTEGER
      <br />Legal values:
        0 .. 2147483647
 <br>
 <a href="#TimeInterval">TimeInterval</a>

  </td><td>Create</td>
<td>
<p>
Note: this object is based on the <a href="#TimeInterval"> TimeInterval TEXTUAL-CONVENTION</a>.
</p>
<pre>
This object should reflect the expected maximum round
trip time for communicating with the transport address
defined by this row.  When a message is sent to this
address, and a response (if one is expected) is not
received within this time period, an implementation
may assume that the response will not be delivered.

Note that the time interval that an application waits
for a response may actually be derived from the value
of this object.  The method for deriving the actual time
interval is implementation dependent.  One such method
is to derive the expected round trip time based on a
particular retransmission algorithm and on the number
of timeouts which have occurred.  The type of message may
also be considered when deriving expected round trip
times for retransmissions.  For example, if a message is
being sent with a securityLevel that indicates both

authentication and privacy, the derived value may be
increased to compensate for extra processing time spent
during authentication and encryption processing.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="snmpTargetAddrRetryCount" />
5
<br /><b>snmpTargetAddrRetryCount</b>

</td><td>
  INTEGER32
      <br />Legal values:
        0 .. 255

  </td><td>Create</td>
<td>
<pre>
This object specifies a default number of retries to be
attempted when a response is not received for a generated
message.  An application may provide its own retry count,
in which case the value of this object is ignored.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="snmpTargetAddrTagList" />
6
<br /><b>snmpTargetAddrTagList</b>

</td><td>
  OCTETSTR
      <br />Legal Lengths:
        0 .. 255
 <br>
 <a href="#SnmpTagList">SnmpTagList</a>

  </td><td>Create</td>
<td>
<p>
Note: this object is based on the <a href="#SnmpTagList"> SnmpTagList TEXTUAL-CONVENTION</a>.
</p>
<pre>
This object contains a list of tag values which are
used to select target addresses for a particular
operation.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="snmpTargetAddrParams" />
7
<br /><b>snmpTargetAddrParams</b>

</td><td>
  OCTETSTR
      <br />Legal Lengths:
        1 .. 32
 <br>
 <a href="#SnmpAdminString">SnmpAdminString</a>

  </td><td>Create</td>
<td>
<p>
Note: this object is based on the <a href="#SnmpAdminString"> SnmpAdminString TEXTUAL-CONVENTION</a>.
</p>
<pre>
The value of this object identifies an entry in the
snmpTargetParamsTable.  The identified entry
contains SNMP parameters to be used when generating
messages to be sent to this transport address.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="snmpTargetAddrStorageType" />
8
<br /><b>snmpTargetAddrStorageType</b>

</td><td>
  INTEGER
 <br>
 <a href="#StorageType">StorageType</a>
     <br>(ENUM list below)

  </td><td>Create</td>
<td>
<p>
Note: this object is based on the <a href="#StorageType"> StorageType TEXTUAL-CONVENTION</a>.
</p>
<pre>
The storage type for this conceptual row.
Conceptual rows having the value 'permanent' need not
allow write-access to any columnar objects in the row.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="snmpTargetAddrRowStatus" />
9
<br /><b>snmpTargetAddrRowStatus</b>

</td><td>
  INTEGER
 <br>
 <a href="#RowStatus">RowStatus</a>
     <br>(ENUM list below)

  </td><td>Create</td>
<td>
<p>
Note: this object is based on the <a href="#RowStatus"> RowStatus TEXTUAL-CONVENTION</a>.
</p>
<pre>
The status of this conceptual row.
To create a row in this table, a manager must
         set this object to either createAndGo(4) or
         createAndWait(5).
Until instances of all corresponding columns are
         appropriately configured, the value of the
         corresponding instance of the snmpTargetAddrRowStatus
         column is 'notReady'.
In particular, a newly created row cannot be made
         active until the corresponding instances of
         snmpTargetAddrTDomain, snmpTargetAddrTAddress, and
         snmpTargetAddrParams have all been set.
The following objects may not be modified while the
         value of this object is active(1):
             - snmpTargetAddrTDomain
             - snmpTargetAddrTAddress
         An attempt to set these objects while the value of
         snmpTargetAddrRowStatus is active(1) will result in
         an inconsistentValue error.
</pre>
</td>
  </tr>
</table>
</ul>
<a name="snmpTargetParamsTable" /><h3>Table snmpTargetParamsTable</h3>
<ul>
  <table>
  <tr><td class="label">Table Name</td><td>snmpTargetParamsTable</td></tr>
  <tr><td class="label">In MIB</td><td>SNMP-TARGET-MIB</td></tr>
  <tr><td class="label">Registered at OID</td><td>.1.3.6.1.6.3.12.1.3</td></tr>
  <tr><td class="label">Table Description</td>
<td>
<pre>
A table of SNMP target information to be used
in the generation of SNMP messages.
</pre>
</td>
</tr>
<tr><td class="label"><a name="snmpTargetParamsEntry" />Row Description</td>
<td>
<pre>
A set of SNMP target information.
Entries in the snmpTargetParamsTable are created and
         deleted using the snmpTargetParamsRowStatus object.
</pre>
</td>
</tr>
  </table>

  <h4>snmpTargetParamsTable Indexes:</h4>

<table>
<tr class="label"><th>Name</th><th>Type</th><th>Access</th><th>Description</th></tr>
  <tr>
  <td>
<a name="snmpTargetParamsName" />
1
<br /><b>snmpTargetParamsName</b>

</td><td>
  OCTETSTR
      <br />Legal Lengths:
        1 .. 32
 <br>
 <a href="#SnmpAdminString">SnmpAdminString</a>

  </td><td>NoAccess</td>
<td>
<p>
Note: this object is based on the <a href="#SnmpAdminString"> SnmpAdminString TEXTUAL-CONVENTION</a>.
</p>
<pre>
The locally arbitrary, but unique identifier associated
with this snmpTargetParamsEntry.
</pre>
</td>
  </tr>
</table>

  <h4>Other snmpTargetParamsTable Columns:</h4>
<table>
<tr class="label"><th>Name</th><th>Type</th><th>Access</th><th>Description</th></tr>
  <tr>
  <td>
<a name="snmpTargetParamsMPModel" />
2
<br /><b>snmpTargetParamsMPModel</b>

</td><td>
  INTEGER
      <br />Legal values:
        0 .. 2147483647
 <br>
 <a href="#SnmpMessageProcessingModel">SnmpMessageProcessingModel</a>

  </td><td>Create</td>
<td>
<p>
Note: this object is based on the <a href="#SnmpMessageProcessingModel"> SnmpMessageProcessingModel TEXTUAL-CONVENTION</a>.
</p>
<pre>
The Message Processing Model to be used when generating
SNMP messages using this entry.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="snmpTargetParamsSecurityModel" />
3
<br /><b>snmpTargetParamsSecurityModel</b>

</td><td>
  INTEGER
      <br />Legal values:
        1 .. 2147483647
 <br>
 <a href="#SnmpSecurityModel">SnmpSecurityModel</a>

  </td><td>Create</td>
<td>
<p>
Note: this object is based on the <a href="#SnmpSecurityModel"> SnmpSecurityModel TEXTUAL-CONVENTION</a>.
</p>
<pre>
The Security Model to be used when generating SNMP
messages using this entry.  An implementation may
choose to return an inconsistentValue error if an
attempt is made to set this variable to a value
for a security model which the implementation does
not support.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="snmpTargetParamsSecurityName" />
4
<br /><b>snmpTargetParamsSecurityName</b>

</td><td>
  OCTETSTR
      <br />Legal Lengths:
        0 .. 255
 <br>
 <a href="#SnmpAdminString">SnmpAdminString</a>

  </td><td>Create</td>
<td>
<p>
Note: this object is based on the <a href="#SnmpAdminString"> SnmpAdminString TEXTUAL-CONVENTION</a>.
</p>
<pre>
The securityName which identifies the Principal on
whose behalf SNMP messages will be generated using
this entry.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="snmpTargetParamsSecurityLevel" />
5
<br /><b>snmpTargetParamsSecurityLevel</b>

</td><td>
  INTEGER
 <br>
 <a href="#SnmpSecurityLevel">SnmpSecurityLevel</a>
     <br>(ENUM list below)

  </td><td>Create</td>
<td>
<p>
Note: this object is based on the <a href="#SnmpSecurityLevel"> SnmpSecurityLevel TEXTUAL-CONVENTION</a>.
</p>
<pre>
The Level of Security to be used when generating
SNMP messages using this entry.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="snmpTargetParamsStorageType" />
6
<br /><b>snmpTargetParamsStorageType</b>

</td><td>
  INTEGER
 <br>
 <a href="#StorageType">StorageType</a>
     <br>(ENUM list below)

  </td><td>Create</td>
<td>
<p>
Note: this object is based on the <a href="#StorageType"> StorageType TEXTUAL-CONVENTION</a>.
</p>
<pre>
The storage type for this conceptual row.
Conceptual rows having the value 'permanent' need not
allow write-access to any columnar objects in the row.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="snmpTargetParamsRowStatus" />
7
<br /><b>snmpTargetParamsRowStatus</b>

</td><td>
  INTEGER
 <br>
 <a href="#RowStatus">RowStatus</a>
     <br>(ENUM list below)

  </td><td>Create</td>
<td>
<p>
Note: this object is based on the <a href="#RowStatus"> RowStatus TEXTUAL-CONVENTION</a>.
</p>
<pre>
The status of this conceptual row.
To create a row in this table, a manager must
         set this object to either createAndGo(4) or
         createAndWait(5).
Until instances of all corresponding columns are
         appropriately configured, the value of the
         corresponding instance of the snmpTargetParamsRowStatus
         column is 'notReady'.
In particular, a newly created row cannot be made
         active until the corresponding
         snmpTargetParamsMPModel,
         snmpTargetParamsSecurityModel,
         snmpTargetParamsSecurityName,
         and snmpTargetParamsSecurityLevel have all been set.
The following objects may not be modified while the
         value of this object is active(1):
             - snmpTargetParamsMPModel
             - snmpTargetParamsSecurityModel
             - snmpTargetParamsSecurityName
             - snmpTargetParamsSecurityLevel
         An attempt to set these objects while the value of
         snmpTargetParamsRowStatus is active(1) will result in
         an inconsistentValue error.
</pre>
</td>
  </tr>
</table>
</ul>
<a name="objects_Deprecated" />
  <hr />
  <h1><font color="red">DEPRECATED OR OBSOLETE OR HISTORIC OBJECTS</font></h1>
  <br>
  <table class="deprecated"><tr><td>
<a name="scalar_notcurrent" />
<h2>SCALAR OBJECTS</h2>
<ul>
<table>
<tr><th>Name</th><th>Type</th><th>Access</th><th>OID</th><th>Description</th></tr>
</table>
</ul>

<h2>TABLE OBJECTS</h2>

<br>
  </table>
<hr />
<a name="notifications" />
<h2>NOTIFICATIONS</h2>
<ul>
<p>
</ul>


<br>
<hr />
<a name="textconventions" />
<h2>TEXTUAL CONVENTIONS</h2>
<ul>
<p>
These TEXTUAL-CONVENTIONS are used in other parts of the document
above.  They are SNMP's way of defining a datatype that is used
repeatedly by other MIB objects.  Any implementation implementing
objects that use one of these definitions must follow its DESCRIPTION
clause as well as the DESCRIPTION clause of the object itself.
</p>
<table><tr class="label"><th>Name</th><th>Type</th><th>Description</th></tr>
<tr><td><a name="SnmpSecurityLevel">SnmpSecurityLevel</td><td>INTEGER<table class="enums"><tr><th>Value</th><th>Label/Meaning</th></tr><tr><td>1</td><td>noAuthNoPriv</td></tr><tr><td>2</td><td>authNoPriv</td></tr><tr><td>3</td><td>authPriv</td></tr></table></td><td><pre>A Level of Security at which SNMP messages can be
sent or with which operations are being processed;
in particular, one of:

  noAuthNoPriv - without authentication and
                 without privacy,
  authNoPriv   - with authentication but
                 without privacy,
  authPriv     - with authentication and
                 with privacy.

These three values are ordered such that
noAuthNoPriv is less than authNoPriv and
authNoPriv is less than authPriv.
                </pre></td></tr>
<tr><td><a name="TestAndIncr">TestAndIncr</td><td>INTEGER</td><td><pre>Represents integer-valued information used for atomic
operations.  When the management protocol is used to specify
that an object instance having this syntax is to be
modified, the new value supplied via the management protocol
must precisely match the value presently held by the
instance.  If not, the management protocol set operation
fails with an error of `inconsistentValue'.  Otherwise, if
the current value is the maximum value of 2^31-1 (2147483647
decimal), then the value held by the instance is wrapped to
zero; otherwise, the value held by the instance is
incremented by one.  (Note that regardless of whether the
management protocol set operation succeeds, the variable-
binding in the request and response PDUs are identical.)

The value of the ACCESS clause for objects having this
syntax is either `read-write' or `read-create'.  When an
instance of a columnar object having this syntax is created,
any value may be supplied via the management protocol.

When the network management portion of the system is re-
initialized, the value of every object instance having this
syntax must either be incremented from its value prior to
the re-initialization, or (if the value prior to the re-
initialization is unknown) be set to a pseudo-randomly
generated value.</pre></td></tr>
<tr><td><a name="TAddress">TAddress</td><td>OCTETSTR</td><td><pre>Denotes a transport service address.
A TAddress value is always interpreted within the context of a
          TDomain value.  Thus, each definition of a TDomain value must
          be accompanied by a definition of a textual convention for use
          with that TDomain.  Some possible textual conventions, such as
          SnmpUDPAddress for snmpUDPDomain, are defined in the SNMPv2-TM
          MIB module.  Other possible textual conventions are defined in
          other MIB modules.</pre></td></tr>
<tr><td><a name="StorageType">StorageType</td><td>INTEGER<table class="enums"><tr><th>Value</th><th>Label/Meaning</th></tr><tr><td>1</td><td>other</td></tr><tr><td>2</td><td>volatile</td></tr><tr><td>3</td><td>nonVolatile</td></tr><tr><td>4</td><td>permanent</td></tr><tr><td>5</td><td>readOnly</td></tr></table></td><td><pre>Describes the memory realization of a conceptual row.  A
row which is volatile(2) is lost upon reboot.  A row which
is either nonVolatile(3), permanent(4) or readOnly(5), is
backed up by stable storage.  A row which is permanent(4)
can be changed but not deleted.  A row which is readOnly(5)
cannot be changed nor deleted.

If the value of an object with this syntax is either
permanent(4) or readOnly(5), it cannot be written.
Conversely, if the value is either other(1), volatile(2) or
nonVolatile(3), it cannot be modified to be permanent(4) or
readOnly(5).  (All illegal modifications result in a
'wrongValue' error.)

Every usage of this textual convention is required to
specify the columnar objects which a permanent(4) row must
at a minimum allow to be writable.</pre></td></tr>
<tr><td><a name="SnmpSecurityModel">SnmpSecurityModel</td><td>INTEGER</td><td><pre>An identifier that uniquely identifies a
Security Model of the Security Subsystem within
this SNMP Management Architecture.

The values for securityModel are allocated as
follows:

- The zero value does not identify any particular
  security model.

- Values between 1 and 255, inclusive, are reserved
  for standards-track Security Models and are
  managed by the Internet Assigned Numbers Authority
  (IANA).
- Values greater than 255 are allocated to
  enterprise-specific Security Models.  An
  enterprise-specific securityModel value is defined
  to be:

  enterpriseID * 256 + security model within
  enterprise

  For example, the fourth Security Model defined by
  the enterprise whose enterpriseID is 1 would be
  259.

This scheme for allocation of securityModel
values allows for a maximum of 255 standards-
based Security Models, and for a maximum of
256 Security Models per enterprise.

It is believed that the assignment of new
securityModel values will be rare in practice
because the larger the number of simultaneously
utilized Security Models, the larger the
chance that interoperability will suffer.
Consequently, it is believed that such a range
will be sufficient.  In the unlikely event that
the standards committee finds this number to be
insufficient over time, an enterprise number
can be allocated to obtain an additional 256
possible values.

Note that the most significant bit must be zero;
hence, there are 23 bits allocated for various
organizations to design and define non-standard

securityModels.  This limits the ability to
define new proprietary implementations of Security
Models to the first 8,388,608 enterprises.

It is worthwhile to note that, in its encoded
form, the securityModel value will normally
require only a single byte since, in practice,
the leftmost bits will be zero for most messages
and sign extension is suppressed by the encoding
rules.

As of this writing, there are several values
of securityModel defined for use with SNMP or
reserved for use with supporting MIB objects.
They are as follows:

    0  reserved for 'any'
    1  reserved for SNMPv1
    2  reserved for SNMPv2c
    3  User-Based Security Model (USM)
                </pre></td></tr>
<tr><td><a name="SnmpMessageProcessingModel">SnmpMessageProcessingModel</td><td>INTEGER</td><td><pre>An identifier that uniquely identifies a Message
Processing Model of the Message Processing
Subsystem within this SNMP Management Architecture.

The values for messageProcessingModel are
allocated as follows:

- Values between 0 and 255, inclusive, are
  reserved for standards-track Message Processing
  Models and are managed by the Internet Assigned
  Numbers Authority (IANA).

- Values greater than 255 are allocated to
  enterprise-specific Message Processing Models.
  An enterprise messageProcessingModel value is
  defined to be:

  enterpriseID * 256 +
       messageProcessingModel within enterprise

  For example, the fourth Message Processing Model
  defined by the enterprise whose enterpriseID

  is 1 would be 259.

This scheme for allocating messageProcessingModel
values allows for a maximum of 255 standards-
based Message Processing Models, and for a
maximum of 256 Message Processing Models per
enterprise.

It is believed that the assignment of new
messageProcessingModel values will be rare
in practice because the larger the number of
simultaneously utilized Message Processing Models,
the larger the chance that interoperability
will suffer. It is believed that such a range
will be sufficient.  In the unlikely event that
the standards committee finds this number to be
insufficient over time, an enterprise number
can be allocated to obtain an additional 256
possible values.

Note that the most significant bit must be zero;
hence, there are 23 bits allocated for various
organizations to design and define non-standard
messageProcessingModels.  This limits the ability
to define new proprietary implementations of
Message Processing Models to the first 8,388,608
enterprises.

It is worthwhile to note that, in its encoded
form, the messageProcessingModel value will
normally require only a single byte since, in
practice, the leftmost bits will be zero for
most messages and sign extension is suppressed
by the encoding rules.

As of this writing, there are several values of
messageProcessingModel defined for use with SNMP.
They are as follows:

    0  reserved for SNMPv1
    1  reserved for SNMPv2c
    2  reserved for SNMPv2u and SNMPv2*
    3  reserved for SNMPv3
                </pre></td></tr>
<tr><td><a name="TDomain">TDomain</td><td>OBJECTID</td><td><pre>Denotes a kind of transport service.
Some possible values, such as snmpUDPDomain, are defined in
          the SNMPv2-TM MIB module.  Other possible values are defined
          in other MIB modules.</pre></td></tr>
<tr><td><a name="TimeInterval">TimeInterval</td><td>INTEGER</td><td><pre>A period of time, measured in units of 0.01 seconds.</pre></td></tr>
<tr><td><a name="SnmpTagList">SnmpTagList</td><td>OCTETSTR</td><td><pre>An octet string containing a list of tag values.
Tag values are preferably in human-readable form.

To facilitate internationalization, this information
is represented using the ISO/IEC IS 10646-1 character
set, encoded as an octet string using the UTF-8
character encoding scheme described in RFC 2279.

Since additional code points are added by amendments
to the 10646 standard from time to time,
implementations must be prepared to encounter any code
point from 0x00000000 to 0x7fffffff.

The use of control codes should be avoided, except as
described below.

For code points not directly supported by user
interface hardware or software, an alternative means
of entry and display, such as hexadecimal, may be
provided.

For information encoded in 7-bit US-ASCII, the UTF-8
representation is identical to the US-ASCII encoding.

An object of this type contains a list of tag values
which are used to select a set of entries in a table.

A tag value is an arbitrary string of octets, but
may not contain a delimiter character.  Delimiter
characters are defined to be one of the following:

    -  An ASCII space character (0x20).

    -  An ASCII TAB character (0x09).

    -  An ASCII carriage return (CR) character (0x0D).

    -  An ASCII line feed (LF) character (0x0A).

Delimiter characters are used to separate tag values

in a tag list.  Only a single delimiter character may
occur between two tag values.  A tag value may not
have a zero length.  These constraints imply certain
restrictions on the contents of this object:

    - There cannot be a leading or trailing delimiter
      character.

    - There cannot be multiple adjacent delimiter
      characters.

Some examples of valid tag lists are:

    - ''                        -- an empty list

    - 'acme'                    -- list of one tag

    - 'host router bridge'      -- list of several tags

Note that although a tag value may not have a length of
zero, an empty string is still valid.  This indicates
an empty list (i.e. there are no tag values in the list).

The use of the tag list to select table entries is
application and MIB specific.  Typically, an application
will provide one or more tag values, and any entry
which contains some combination of these tag values
will be selected.</pre></td></tr>
<tr><td><a name="RowStatus">RowStatus</td><td>INTEGER<table class="enums"><tr><th>Value</th><th>Label/Meaning</th></tr><tr><td>1</td><td>active</td></tr><tr><td>2</td><td>notInService</td></tr><tr><td>3</td><td>notReady</td></tr><tr><td>4</td><td>createAndGo</td></tr><tr><td>5</td><td>createAndWait</td></tr><tr><td>6</td><td>destroy</td></tr></table></td><td><pre>The RowStatus textual convention is used to manage the
creation and deletion of conceptual rows, and is used as the
value of the SYNTAX clause for the status column of a
conceptual row (as described in Section 7.7.1 of [2].)

The status column has six defined values:

     - `active', which indicates that the conceptual row is
     available for use by the managed device;

     - `notInService', which indicates that the conceptual
     row exists in the agent, but is unavailable for use by
     the managed device (see NOTE below); 'notInService' has
     no implication regarding the internal consistency of
     the row, availability of resources, or consistency with
     the current state of the managed device;

     - `notReady', which indicates that the conceptual row
     exists in the agent, but is missing information
     necessary in order to be available for use by the
     managed device (i.e., one or more required columns in
     the conceptual row have not been instanciated);

     - `createAndGo', which is supplied by a management
     station wishing to create a new instance of a
     conceptual row and to have its status automatically set
     to active, making it available for use by the managed
     device;

     - `createAndWait', which is supplied by a management
     station wishing to create a new instance of a
     conceptual row (but not make it available for use by
     the managed device); and,
     - `destroy', which is supplied by a management station
     wishing to delete all of the instances associated with
     an existing conceptual row.

Whereas five of the six values (all except `notReady') may
be specified in a management protocol set operation, only
three values will be returned in response to a management
protocol retrieval operation:  `notReady', `notInService' or
`active'.  That is, when queried, an existing conceptual row
has only three states:  it is either available for use by
the managed device (the status column has value `active');
it is not available for use by the managed device, though
the agent has sufficient information to attempt to make it
so (the status column has value `notInService'); or, it is
not available for use by the managed device, and an attempt
to make it so would fail because the agent has insufficient
information (the state column has value `notReady').

                         NOTE WELL

     This textual convention may be used for a MIB table,
     irrespective of whether the values of that table's
     conceptual rows are able to be modified while it is
     active, or whether its conceptual rows must be taken
     out of service in order to be modified.  That is, it is
     the responsibility of the DESCRIPTION clause of the
     status column to specify whether the status column must
     not be `active' in order for the value of some other
     column of the same conceptual row to be modified.  If
     such a specification is made, affected columns may be
     changed by an SNMP set PDU if the RowStatus would not
     be equal to `active' either immediately before or after
     processing the PDU.  In other words, if the PDU also
     contained a varbind that would change the RowStatus
     value, the column in question may be changed if the
     RowStatus was not equal to `active' as the PDU was
     received, or if the varbind sets the status</pre></td></tr>
<tr><td><a name="SnmpAdminString">SnmpAdminString</td><td>OCTETSTR</td><td><pre>An octet string containing administrative
information, preferably in human-readable form.

To facilitate internationalization, this
information is represented using the ISO/IEC
IS 10646-1 character set, encoded as an octet
string using the UTF-8 transformation format
described in [RFC2279].

Since additional code points are added by
amendments to the 10646 standard from time
to time, implementations must be prepared to
encounter any code point from 0x00000000 to
0x7fffffff.  Byte sequences that do not
correspond to the valid UTF-8 encoding of a
code point or are outside this range are
prohibited.

The use of control codes should be avoided.

When it is necessary to represent a newline,
the control code sequence CR LF should be used.

The use of leading or trailing white space should
be avoided.

For code points not directly supported by user
interface hardware or software, an alternative
means of entry and display, such as hexadecimal,
may be provided.

For information encoded in 7-bit US-ASCII,
the UTF-8 encoding is identical to the
US-ASCII encoding.

UTF-8 may require multiple bytes to represent a
single character / code point; thus the length
of this object in octets may be different from
the number of characters encoded.  Similarly,
size constraints refer to the number of encoded
octets, not the number of characters represented
by an encoding.

Note that when this TC is used for an object that
is used or envisioned to be used as an index, then
a SIZE restriction MUST be specified so that the
number of sub-identifiers for any object instance
does not exceed the limit of 128, as defined by
[RFC3416].

Note that the size of an SnmpAdminString object is
measured in octets, not characters.
                </pre></td></tr>
</table></ul>

<a name="treeview" />
<h2>TREE VIEW</h2>
<p>Tree view generated by running: <b>snmptranslate -Tp SNMP-TARGET-MIB::snmpTargetMIB</b></p>
<pre>
+--<a href="#snmpTargetMIB">snmpTargetMIB</a>(12)
   |
   +--<a href="#snmpTargetObjects">snmpTargetObjects</a>(1)
   |  |
   |  +-- -RW- INTEGER   <a href="#snmpTargetSpinLock">snmpTargetSpinLock</a>(1)
   |  |        Textual Convention: <a href="#TestAndIncr">TestAndIncr</a>
   |  |        Range: 0..2147483647
   |  |
   |  +--<a href="#snmpTargetAddrTable">snmpTargetAddrTable</a>(2)
   |  |  |
   |  |  +--<a href="#snmpTargetAddrEntry">snmpTargetAddrEntry</a>(1)
   |  |     |  Index: snmpTargetAddrName
   |  |     |
   |  |     +-- ---- String    <a href="#snmpTargetAddrName">snmpTargetAddrName</a>(1)
   |  |     |        Textual Convention: <a href="#SnmpAdminString">SnmpAdminString</a>
   |  |     |        Size: 1..32
   |  |     +-- CR-- ObjID     <a href="#snmpTargetAddrTDomain">snmpTargetAddrTDomain</a>(2)
   |  |     |        Textual Convention: <a href="#TDomain">TDomain</a>
   |  |     +-- CR-- String    <a href="#snmpTargetAddrTAddress">snmpTargetAddrTAddress</a>(3)
   |  |     |        Textual Convention: <a href="#TAddress">TAddress</a>
   |  |     |        Size: 1..255
   |  |     +-- CR-- INTEGER   <a href="#snmpTargetAddrTimeout">snmpTargetAddrTimeout</a>(4)
   |  |     |        Textual Convention: <a href="#TimeInterval">TimeInterval</a>
   |  |     |        Range: 0..2147483647
   |  |     +-- CR-- Integer32 <a href="#snmpTargetAddrRetryCount">snmpTargetAddrRetryCount</a>(5)
   |  |     |        Range: 0..255
   |  |     +-- CR-- String    <a href="#snmpTargetAddrTagList">snmpTargetAddrTagList</a>(6)
   |  |     |        Textual Convention: <a href="#SnmpTagList">SnmpTagList</a>
   |  |     |        Size: 0..255
   |  |     +-- CR-- String    <a href="#snmpTargetAddrParams">snmpTargetAddrParams</a>(7)
   |  |     |        Textual Convention: <a href="#SnmpAdminString">SnmpAdminString</a>
   |  |     |        Size: 1..32
   |  |     +-- CR-- EnumVal   <a href="#snmpTargetAddrStorageType">snmpTargetAddrStorageType</a>(8)
   |  |     |        Textual Convention: <a href="#StorageType">StorageType</a>
   |  |     |        Values: other(1), volatile(2), nonVolatile(3), permanent(4), readOnly(5)
   |  |     +-- CR-- EnumVal   <a href="#snmpTargetAddrRowStatus">snmpTargetAddrRowStatus</a>(9)
   |  |              Textual Convention: <a href="#RowStatus">RowStatus</a>
   |  |              Values: active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
   |  |
   |  +--<a href="#snmpTargetParamsTable">snmpTargetParamsTable</a>(3)
   |  |  |
   |  |  +--<a href="#snmpTargetParamsEntry">snmpTargetParamsEntry</a>(1)
   |  |     |  Index: snmpTargetParamsName
   |  |     |
   |  |     +-- ---- String    <a href="#snmpTargetParamsName">snmpTargetParamsName</a>(1)
   |  |     |        Textual Convention: <a href="#SnmpAdminString">SnmpAdminString</a>
   |  |     |        Size: 1..32
   |  |     +-- CR-- INTEGER   <a href="#snmpTargetParamsMPModel">snmpTargetParamsMPModel</a>(2)
   |  |     |        Textual Convention: <a href="#SnmpMessageProcessingModel">SnmpMessageProcessingModel</a>
   |  |     |        Range: 0..2147483647
   |  |     +-- CR-- INTEGER   <a href="#snmpTargetParamsSecurityModel">snmpTargetParamsSecurityModel</a>(3)
   |  |     |        Textual Convention: <a href="#SnmpSecurityModel">SnmpSecurityModel</a>
   |  |     |        Range: 1..2147483647
   |  |     +-- CR-- String    <a href="#snmpTargetParamsSecurityName">snmpTargetParamsSecurityName</a>(4)
   |  |     |        Textual Convention: <a href="#SnmpAdminString">SnmpAdminString</a>
   |  |     |        Size: 0..255
   |  |     +-- CR-- EnumVal   <a href="#snmpTargetParamsSecurityLevel">snmpTargetParamsSecurityLevel</a>(5)
   |  |     |        Textual Convention: <a href="#SnmpSecurityLevel">SnmpSecurityLevel</a>
   |  |     |        Values: noAuthNoPriv(1), authNoPriv(2), authPriv(3)
   |  |     +-- CR-- EnumVal   <a href="#snmpTargetParamsStorageType">snmpTargetParamsStorageType</a>(6)
   |  |     |        Textual Convention: <a href="#StorageType">StorageType</a>
   |  |     |        Values: other(1), volatile(2), nonVolatile(3), permanent(4), readOnly(5)
   |  |     +-- CR-- EnumVal   <a href="#snmpTargetParamsRowStatus">snmpTargetParamsRowStatus</a>(7)
   |  |              Textual Convention: <a href="#RowStatus">RowStatus</a>
   |  |              Values: active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
   |  |
   |  +-- -R-- Counter   <a href="#snmpUnavailableContexts">snmpUnavailableContexts</a>(4)
   |  +-- -R-- Counter   <a href="#snmpUnknownContexts">snmpUnknownContexts</a>(5)
   |
   +--<a href="#snmpTargetConformance">snmpTargetConformance</a>(3)
      |
      +--<a href="#snmpTargetCompliances">snmpTargetCompliances</a>(1)
      |  |
      |  +--<a href="#snmpTargetCommandResponderCompliance">snmpTargetCommandResponderCompliance</a>(1)
      |
      +--<a href="#snmpTargetGroups">snmpTargetGroups</a>(2)
         |
         +--<a href="#snmpTargetBasicGroup">snmpTargetBasicGroup</a>(1)
         +--<a href="#snmpTargetResponseGroup">snmpTargetResponseGroup</a>(2)
         +--<a href="#snmpTargetCommandResponderGroup">snmpTargetCommandResponderGroup</a>(3)
</pre>
<!-- CONTENT END -->