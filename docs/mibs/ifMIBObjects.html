---
section: documentation
---
<!-- CONTENT START -->
<h2>INTRODUCTION</h2>
<ul>
<p>
This is a summary of information regarding objects below the <b>ifMIBObjects</b>
MIB object, which is defined within the <b>IF-MIB</b> MIB
document as <b>.1.3.6.1.2.1.31.1</b>.
</p>
</ul>
<h2>TABLE OF CONTENTS</h2>
<ul>
<h3><a href="#objects_Current">Current Objects</a></h3>
<ul>
<li><a href="#scalar_current">Scalars</a></li>
  <li><a href="#ifXTable">ifXTable</a></li>
  <li><a href="#ifStackTable">ifStackTable</a></li>
  <li><a href="#ifRcvAddressTable">ifRcvAddressTable</a></li>
</ul>
<h3><a href="#objects_Deprecated">Deprecated Objects</a></h3>
<ul>
<li><a href="#scalar_notcurrent">Deprecated Scalars</a></li>
  <li><a href="#ifTestTable">ifTestTable</a></li>
</ul>
<h3><a href="#notifications">Notifications</a></h3>
<h3><a href="#textconventions">Textual Conventions</a></h3>
<h3><a href="#treeview">Tree-based view</a></h3>
</ul>
<a name="objects_Current" />
<a name="scalar_current" />
<h2>SCALAR OBJECTS</h2>
<ul>
<table>
<tr><th>Name</th><th>Type</th><th>Access</th><th>OID</th><th>Description</th></tr>
  <tr>
  <td>
<a name="ifTableLastChange" />
5
<br /><b>ifTableLastChange</b>

</td><td>
  TICKS

  </td><td>ReadOnly</td>
    <td>.1.3.6.1.2.1.31.1.5</td>
<td>
<pre>
The value of sysUpTime at the time of the last creation or
deletion of an entry in the ifTable.  If the number of
entries has been unchanged since the last re-initialization
of the local network management subsystem, then this object
contains a zero value.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="ifStackLastChange" />
6
<br /><b>ifStackLastChange</b>

</td><td>
  TICKS

  </td><td>ReadOnly</td>
    <td>.1.3.6.1.2.1.31.1.6</td>
<td>
<pre>
The value of sysUpTime at the time of the last change of
the (whole) interface stack.  A change of the interface
stack is defined to be any creation, deletion, or change in
value of any instance of ifStackStatus.  If the interface
stack has been unchanged since the last re-initialization of
the local network management subsystem, then this object
contains a zero value.
</pre>
</td>
  </tr>
</table>
</ul>

<h2>TABLE OBJECTS</h2>
<a name="ifXTable" /><h3>Table ifXTable</h3>
<ul>
  <table>
  <tr><td class="label">Table Name</td><td>ifXTable</td></tr>
  <tr><td class="label">In MIB</td><td>IF-MIB</td></tr>
  <tr><td class="label">Registered at OID</td><td>.1.3.6.1.2.1.31.1.1</td></tr>
  <tr><td class="label">Table Description</td>
<td>
<pre>
A list of interface entries.  The number of entries is
given by the value of ifNumber.  This table contains
additional objects for the interface table.
</pre>
</td>
</tr>
<tr><td class="label"><a name="ifXEntry" />Row Description</td>
<td>
<pre>
An entry containing additional management information
applicable to a particular interface.
</pre>
</td>
</tr>
  </table>

  <h4>ifXTable Indexes:</h4>

<table>
<tr class="label"><th>Name</th><th>Type</th><th>Access</th><th>Description</th></tr>
  <tr>
  <td>
<a name="ifIndex" />
1
<br /><b>ifIndex</b>

</td><td>
  INTEGER32
      <br />Legal values:
        1 .. 2147483647
 <br>
 <a href="#InterfaceIndex">InterfaceIndex</a>

  </td><td>ReadOnly</td>
<td>
<p>
Note: this object is based on the <a href="#InterfaceIndex"> InterfaceIndex TEXTUAL-CONVENTION</a>.
</p>
<pre>
A unique value, greater than zero, for each interface.  It
is recommended that values are assigned contiguously
starting from 1.  The value for each interface sub-layer
must remain constant at least from one re-initialization of
the entity's network management system to the next re-
initialization.
</pre>
</td>
  </tr>
</table>

  <h4>Other ifXTable Columns:</h4>
<table>
<tr class="label"><th>Name</th><th>Type</th><th>Access</th><th>Description</th></tr>
  <tr>
  <td>
<a name="ifName" />
1
<br /><b>ifName</b>

</td><td>
  OCTETSTR
      <br />Legal Lengths:
        0 .. 255
 <br>
 <a href="#DisplayString">DisplayString</a>

  </td><td>ReadOnly</td>
<td>
<p>
Note: this object is based on the <a href="#DisplayString"> DisplayString TEXTUAL-CONVENTION</a>.
</p>
<pre>
The textual name of the interface.  The value of this
object should be the name of the interface as assigned by
the local device and should be suitable for use in commands
entered at the device's `console'.  This might be a text
name, such as `le0' or a simple port number, such as `1',
depending on the interface naming syntax of the device.  If
several entries in the ifTable together represent a single
interface as named by the device, then each will have the
same value of ifName.  Note that for an agent which responds
to SNMP queries concerning an interface on some other
(proxied) device, then the value of ifName for such an
interface is the proxied device's local name for it.

If there is no local name, or this object is otherwise not
applicable, then this object contains a zero-length string.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="ifInMulticastPkts" />
2
<br /><b>ifInMulticastPkts</b>

</td><td>
  COUNTER

  </td><td>ReadOnly</td>
<td>
<pre>
The number of packets, delivered by this sub-layer to a
higher (sub-)layer, which were addressed to a multicast
address at this sub-layer.  For a MAC layer protocol, this
includes both Group and Functional addresses.

Discontinuities in the value of this counter can occur at
re-initialization of the management system, and at other

times as indicated by the value of
ifCounterDiscontinuityTime.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="ifInBroadcastPkts" />
3
<br /><b>ifInBroadcastPkts</b>

</td><td>
  COUNTER

  </td><td>ReadOnly</td>
<td>
<pre>
The number of packets, delivered by this sub-layer to a
higher (sub-)layer, which were addressed to a broadcast
address at this sub-layer.

Discontinuities in the value of this counter can occur at
re-initialization of the management system, and at other
times as indicated by the value of
ifCounterDiscontinuityTime.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="ifOutMulticastPkts" />
4
<br /><b>ifOutMulticastPkts</b>

</td><td>
  COUNTER

  </td><td>ReadOnly</td>
<td>
<pre>
The total number of packets that higher-level protocols
requested be transmitted, and which were addressed to a
multicast address at this sub-layer, including those that
were discarded or not sent.  For a MAC layer protocol, this
includes both Group and Functional addresses.

Discontinuities in the value of this counter can occur at
re-initialization of the management system, and at other
times as indicated by the value of
ifCounterDiscontinuityTime.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="ifOutBroadcastPkts" />
5
<br /><b>ifOutBroadcastPkts</b>

</td><td>
  COUNTER

  </td><td>ReadOnly</td>
<td>
<pre>
The total number of packets that higher-level protocols
requested be transmitted, and which were addressed to a
broadcast address at this sub-layer, including those that
were discarded or not sent.

Discontinuities in the value of this counter can occur at
re-initialization of the management system, and at other

times as indicated by the value of
ifCounterDiscontinuityTime.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="ifHCInOctets" />
6
<br /><b>ifHCInOctets</b>

</td><td>
  COUNTER64

  </td><td>ReadOnly</td>
<td>
<pre>
The total number of octets received on the interface,
including framing characters.  This object is a 64-bit
version of ifInOctets.

Discontinuities in the value of this counter can occur at
re-initialization of the management system, and at other
times as indicated by the value of
ifCounterDiscontinuityTime.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="ifHCInUcastPkts" />
7
<br /><b>ifHCInUcastPkts</b>

</td><td>
  COUNTER64

  </td><td>ReadOnly</td>
<td>
<pre>
The number of packets, delivered by this sub-layer to a
higher (sub-)layer, which were not addressed to a multicast
or broadcast address at this sub-layer.  This object is a
64-bit version of ifInUcastPkts.

Discontinuities in the value of this counter can occur at
re-initialization of the management system, and at other
times as indicated by the value of
ifCounterDiscontinuityTime.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="ifHCInMulticastPkts" />
8
<br /><b>ifHCInMulticastPkts</b>

</td><td>
  COUNTER64

  </td><td>ReadOnly</td>
<td>
<pre>
The number of packets, delivered by this sub-layer to a
higher (sub-)layer, which were addressed to a multicast
address at this sub-layer.  For a MAC layer protocol, this
includes both Group and Functional addresses.  This object
is a 64-bit version of ifInMulticastPkts.

Discontinuities in the value of this counter can occur at
re-initialization of the management system, and at other
times as indicated by the value of
ifCounterDiscontinuityTime.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="ifHCInBroadcastPkts" />
9
<br /><b>ifHCInBroadcastPkts</b>

</td><td>
  COUNTER64

  </td><td>ReadOnly</td>
<td>
<pre>
The number of packets, delivered by this sub-layer to a
higher (sub-)layer, which were addressed to a broadcast
address at this sub-layer.  This object is a 64-bit version
of ifInBroadcastPkts.

Discontinuities in the value of this counter can occur at
re-initialization of the management system, and at other
times as indicated by the value of
ifCounterDiscontinuityTime.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="ifHCOutOctets" />
10
<br /><b>ifHCOutOctets</b>

</td><td>
  COUNTER64

  </td><td>ReadOnly</td>
<td>
<pre>
The total number of octets transmitted out of the
interface, including framing characters.  This object is a
64-bit version of ifOutOctets.

Discontinuities in the value of this counter can occur at
re-initialization of the management system, and at other
times as indicated by the value of
ifCounterDiscontinuityTime.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="ifHCOutUcastPkts" />
11
<br /><b>ifHCOutUcastPkts</b>

</td><td>
  COUNTER64

  </td><td>ReadOnly</td>
<td>
<pre>
The total number of packets that higher-level protocols
requested be transmitted, and which were not addressed to a
multicast or broadcast address at this sub-layer, including
those that were discarded or not sent.  This object is a
64-bit version of ifOutUcastPkts.

Discontinuities in the value of this counter can occur at
re-initialization of the management system, and at other
times as indicated by the value of
ifCounterDiscontinuityTime.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="ifHCOutMulticastPkts" />
12
<br /><b>ifHCOutMulticastPkts</b>

</td><td>
  COUNTER64

  </td><td>ReadOnly</td>
<td>
<pre>
The total number of packets that higher-level protocols
requested be transmitted, and which were addressed to a
multicast address at this sub-layer, including those that
were discarded or not sent.  For a MAC layer protocol, this
includes both Group and Functional addresses.  This object
is a 64-bit version of ifOutMulticastPkts.

Discontinuities in the value of this counter can occur at
re-initialization of the management system, and at other
times as indicated by the value of
ifCounterDiscontinuityTime.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="ifHCOutBroadcastPkts" />
13
<br /><b>ifHCOutBroadcastPkts</b>

</td><td>
  COUNTER64

  </td><td>ReadOnly</td>
<td>
<pre>
The total number of packets that higher-level protocols
requested be transmitted, and which were addressed to a
broadcast address at this sub-layer, including those that
were discarded or not sent.  This object is a 64-bit version
of ifOutBroadcastPkts.

Discontinuities in the value of this counter can occur at
re-initialization of the management system, and at other
times as indicated by the value of
ifCounterDiscontinuityTime.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="ifLinkUpDownTrapEnable" />
14
<br /><b>ifLinkUpDownTrapEnable</b>

</td><td>
  INTEGER
      <table class="enum">
      <tr><th>Value</th><th>Label/Meaning</th></tr>
        <tr><td>1</td><td>enabled</td></tr>
        <tr><td>2</td><td>disabled</td></tr>
      </table>

  </td><td>ReadWrite</td>
<td>
<pre>
Indicates whether linkUp/linkDown traps should be generated
for this interface.

By default, this object should have the value enabled(1) for
interfaces which do not operate on 'top' of any other
interface (as defined in the ifStackTable), and disabled(2)
otherwise.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="ifHighSpeed" />
15
<br /><b>ifHighSpeed</b>

</td><td>
  GAUGE

  </td><td>ReadOnly</td>
<td>
<pre>
An estimate of the interface's current bandwidth in units
of 1,000,000 bits per second.  If this object reports a
value of `n' then the speed of the interface is somewhere in
the range of `n-500,000' to `n+499,999'.  For interfaces
which do not vary in bandwidth or for those where no
accurate estimation can be made, this object should contain
the nominal bandwidth.  For a sub-layer which has no concept
of bandwidth, this object should be zero.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="ifPromiscuousMode" />
16
<br /><b>ifPromiscuousMode</b>

</td><td>
  INTEGER
 <br>
 <a href="#TruthValue">TruthValue</a>
     <br>(ENUM list below)

  </td><td>ReadWrite</td>
<td>
<p>
Note: this object is based on the <a href="#TruthValue"> TruthValue TEXTUAL-CONVENTION</a>.
</p>
<pre>
This object has a value of false(2) if this interface only
accepts packets/frames that are addressed to this station.
This object has a value of true(1) when the station accepts
all packets/frames transmitted on the media.  The value
true(1) is only legal on certain types of media.  If legal,
setting this object to a value of true(1) may require the
interface to be reset before becoming effective.

The value of ifPromiscuousMode does not affect the reception
of broadcast and multicast packets/frames by the interface.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="ifConnectorPresent" />
17
<br /><b>ifConnectorPresent</b>

</td><td>
  INTEGER
 <br>
 <a href="#TruthValue">TruthValue</a>
     <br>(ENUM list below)

  </td><td>ReadOnly</td>
<td>
<p>
Note: this object is based on the <a href="#TruthValue"> TruthValue TEXTUAL-CONVENTION</a>.
</p>
<pre>
This object has the value 'true(1)' if the interface
sublayer has a physical connector and the value 'false(2)'
otherwise.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="ifAlias" />
18
<br /><b>ifAlias</b>

</td><td>
  OCTETSTR
      <br />Legal Lengths:
        0 .. 64
 <br>
 <a href="#DisplayString">DisplayString</a>

  </td><td>ReadWrite</td>
<td>
<p>
Note: this object is based on the <a href="#DisplayString"> DisplayString TEXTUAL-CONVENTION</a>.
</p>
<pre>
This object is an 'alias' name for the interface as
specified by a network manager, and provides a non-volatile
'handle' for the interface.

On the first instantiation of an interface, the value of
ifAlias associated with that interface is the zero-length
string.  As and when a value is written into an instance of
ifAlias through a network management set operation, then the
agent must retain the supplied value in the ifAlias instance
associated with the same interface for as long as that
interface remains instantiated, including across all re-
initializations/reboots of the network management system,
including those which result in a change of the interface's
ifIndex value.

An example of the value which a network manager might store
in this object for a WAN interface is the (Telco's) circuit
number/identifier of the interface.

Some agents may support write-access only for interfaces
having particular values of ifType.  An agent which supports
write access to this object is required to keep the value in
non-volatile storage, but it may limit the length of new
values depending on how much storage is already occupied by
the current values for other interfaces.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="ifCounterDiscontinuityTime" />
19
<br /><b>ifCounterDiscontinuityTime</b>

</td><td>
  TICKS
 <br>
 <a href="#TimeStamp">TimeStamp</a>

  </td><td>ReadOnly</td>
<td>
<p>
Note: this object is based on the <a href="#TimeStamp"> TimeStamp TEXTUAL-CONVENTION</a>.
</p>
<pre>
The value of sysUpTime on the most recent occasion at which
any one or more of this interface's counters suffered a
discontinuity.  The relevant counters are the specific
instances associated with this interface of any Counter32 or

Counter64 object contained in the ifTable or ifXTable.  If
no such discontinuities have occurred since the last re-
initialization of the local management subsystem, then this
object contains a zero value.
</pre>
</td>
  </tr>
</table>
</ul>
<a name="ifStackTable" /><h3>Table ifStackTable</h3>
<ul>
  <table>
  <tr><td class="label">Table Name</td><td>ifStackTable</td></tr>
  <tr><td class="label">In MIB</td><td>IF-MIB</td></tr>
  <tr><td class="label">Registered at OID</td><td>.1.3.6.1.2.1.31.1.2</td></tr>
  <tr><td class="label">Table Description</td>
<td>
<pre>
The table containing information on the relationships
between the multiple sub-layers of network interfaces.  In
particular, it contains information on which sub-layers run
'on top of' which other sub-layers, where each sub-layer
corresponds to a conceptual row in the ifTable.  For
example, when the sub-layer with ifIndex value x runs over
the sub-layer with ifIndex value y, then this table
contains:

  ifStackStatus.x.y=active

For each ifIndex value, I, which identifies an active
interface, there are always at least two instantiated rows
in this table associated with I.  For one of these rows, I
is the value of ifStackHigherLayer; for the other, I is the
value of ifStackLowerLayer.  (If I is not involved in
multiplexing, then these are the only two rows associated
with I.)

For example, two rows exist even for an interface which has
no others stacked on top or below it:

  ifStackStatus.0.x=active
  ifStackStatus.x.0=active 
</pre>
</td>
</tr>
<tr><td class="label"><a name="ifStackEntry" />Row Description</td>
<td>
<pre>
Information on a particular relationship between two sub-
layers, specifying that one sub-layer runs on 'top' of the
other sub-layer.  Each sub-layer corresponds to a conceptual
row in the ifTable.
</pre>
</td>
</tr>
  </table>

  <h4>ifStackTable Indexes:</h4>

<table>
<tr class="label"><th>Name</th><th>Type</th><th>Access</th><th>Description</th></tr>
  <tr>
  <td>
<a name="ifStackHigherLayer" />
1
<br /><b>ifStackHigherLayer</b>

</td><td>
  INTEGER32
      <br />Legal values:
        0 .. 2147483647
 <br>
 <a href="#InterfaceIndexOrZero">InterfaceIndexOrZero</a>

  </td><td>NoAccess</td>
<td>
<p>
Note: this object is based on the <a href="#InterfaceIndexOrZero"> InterfaceIndexOrZero TEXTUAL-CONVENTION</a>.
</p>
<pre>
The value of ifIndex corresponding to the higher sub-layer
of the relationship, i.e., the sub-layer which runs on 'top'
of the sub-layer identified by the corresponding instance of
ifStackLowerLayer.  If there is no higher sub-layer (below
the internetwork layer), then this object has the value 0.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="ifStackLowerLayer" />
2
<br /><b>ifStackLowerLayer</b>

</td><td>
  INTEGER32
      <br />Legal values:
        0 .. 2147483647
 <br>
 <a href="#InterfaceIndexOrZero">InterfaceIndexOrZero</a>

  </td><td>NoAccess</td>
<td>
<p>
Note: this object is based on the <a href="#InterfaceIndexOrZero"> InterfaceIndexOrZero TEXTUAL-CONVENTION</a>.
</p>
<pre>
The value of ifIndex corresponding to the lower sub-layer
of the relationship, i.e., the sub-layer which runs 'below'
the sub-layer identified by the corresponding instance of
ifStackHigherLayer.  If there is no lower sub-layer, then
this object has the value 0.
</pre>
</td>
  </tr>
</table>

  <h4>Other ifStackTable Columns:</h4>
<table>
<tr class="label"><th>Name</th><th>Type</th><th>Access</th><th>Description</th></tr>
  <tr>
  <td>
<a name="ifStackStatus" />
3
<br /><b>ifStackStatus</b>

</td><td>
  INTEGER
 <br>
 <a href="#RowStatus">RowStatus</a>
     <br>(ENUM list below)

  </td><td>Create</td>
<td>
<p>
Note: this object is based on the <a href="#RowStatus"> RowStatus TEXTUAL-CONVENTION</a>.
</p>
<pre>
The status of the relationship between two sub-layers.
Changing the value of this object from 'active' to
            'notInService' or 'destroy' will likely have consequences up
            and down the interface stack.  Thus, write access to this
            object is likely to be inappropriate for some types of
            interfaces, and many implementations will choose not to
            support write-access for any type of interface.
</pre>
</td>
  </tr>
</table>
</ul>
<a name="ifRcvAddressTable" /><h3>Table ifRcvAddressTable</h3>
<ul>
  <table>
  <tr><td class="label">Table Name</td><td>ifRcvAddressTable</td></tr>
  <tr><td class="label">In MIB</td><td>IF-MIB</td></tr>
  <tr><td class="label">Registered at OID</td><td>.1.3.6.1.2.1.31.1.4</td></tr>
  <tr><td class="label">Table Description</td>
<td>
<pre>
This table contains an entry for each address (broadcast,
multicast, or uni-cast) for which the system will receive
packets/frames on a particular interface, except as follows:

- for an interface operating in promiscuous mode, entries
are only required for those addresses for which the system
would receive frames were it not operating in promiscuous
mode.

- for 802.5 functional addresses, only one entry is
required, for the address which has the functional address
bit ANDed with the bit mask of all functional addresses for
which the interface will accept frames.

A system is normally able to use any unicast address which
corresponds to an entry in this table as a source address.
</pre>
</td>
</tr>
<tr><td class="label"><a name="ifRcvAddressEntry" />Row Description</td>
<td>
<pre>
A list of objects identifying an address for which the
system will accept packets/frames on the particular
interface identified by the index value ifIndex.
</pre>
</td>
</tr>
  </table>

  <h4>ifRcvAddressTable Indexes:</h4>

<table>
<tr class="label"><th>Name</th><th>Type</th><th>Access</th><th>Description</th></tr>
  <tr>
  <td>
<a name="ifIndex" />
1
<br /><b>ifIndex</b>

</td><td>
  INTEGER32
      <br />Legal values:
        1 .. 2147483647
 <br>
 <a href="#InterfaceIndex">InterfaceIndex</a>

  </td><td>ReadOnly</td>
<td>
<p>
Note: this object is based on the <a href="#InterfaceIndex"> InterfaceIndex TEXTUAL-CONVENTION</a>.
</p>
<pre>
A unique value, greater than zero, for each interface.  It
is recommended that values are assigned contiguously
starting from 1.  The value for each interface sub-layer
must remain constant at least from one re-initialization of
the entity's network management system to the next re-
initialization.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="ifRcvAddressAddress" />
1
<br /><b>ifRcvAddressAddress</b>

</td><td>
  OCTETSTR
 <br>
 <a href="#PhysAddress">PhysAddress</a>

  </td><td>NoAccess</td>
<td>
<p>
Note: this object is based on the <a href="#PhysAddress"> PhysAddress TEXTUAL-CONVENTION</a>.
</p>
<pre>
An address for which the system will accept packets/frames
on this entry's interface.
</pre>
</td>
  </tr>
</table>

  <h4>Other ifRcvAddressTable Columns:</h4>
<table>
<tr class="label"><th>Name</th><th>Type</th><th>Access</th><th>Description</th></tr>
  <tr>
  <td>
<a name="ifRcvAddressStatus" />
2
<br /><b>ifRcvAddressStatus</b>

</td><td>
  INTEGER
 <br>
 <a href="#RowStatus">RowStatus</a>
     <br>(ENUM list below)

  </td><td>Create</td>
<td>
<p>
Note: this object is based on the <a href="#RowStatus"> RowStatus TEXTUAL-CONVENTION</a>.
</p>
<pre>
This object is used to create and delete rows in the
ifRcvAddressTable.
</pre>
</td>
  </tr>
  <tr>
  <td>
<a name="ifRcvAddressType" />
3
<br /><b>ifRcvAddressType</b>

</td><td>
  INTEGER
      <table class="enum">
      <tr><th>Value</th><th>Label/Meaning</th></tr>
        <tr><td>1</td><td>other</td></tr>
        <tr><td>2</td><td>volatile</td></tr>
        <tr><td>3</td><td>nonVolatile</td></tr>
      </table>

  </td><td>Create</td>
<td>
<pre>
This object has the value nonVolatile(3) for those entries
in the table which are valid and will not be deleted by the
next restart of the managed system.  Entries having the
value volatile(2) are valid and exist, but have not been
saved, so that will not exist after the next restart of the
managed system.  Entries having the value other(1) are valid
and exist but are not classified as to whether they will
continue to exist after the next restart.
</pre>
</td>
  </tr>
</table>
</ul>
<a name="objects_Deprecated" />
  <hr />
  <h1><font color="red">DEPRECATED OR OBSOLETE OR HISTORIC OBJECTS</font></h1>
  <br>
  <table class="deprecated"><tr><td>
<a name="scalar_notcurrent" />
<h2>SCALAR OBJECTS</h2>
<ul>
<table>
<tr><th>Name</th><th>Type</th><th>Access</th><th>OID</th><th>Description</th></tr>
</table>
</ul>

<h2>TABLE OBJECTS</h2>
<a name="ifTestTable" /><h3>Table ifTestTable</h3>
<ul>
  <table>
  <tr><td class="label">Table Name</td><td>ifTestTable</td></tr>
  <tr><td class="label">In MIB</td><td>IF-MIB</td></tr>
  <tr><td class="label">Registered at OID</td><td>.1.3.6.1.2.1.31.1.3</td></tr>
  <tr><td class="label">Table Description</td>
<td>
<pre>
This table contains one entry per interface.  It defines
objects which allow a network manager to instruct an agent
to test an interface for various faults.  Tests for an
interface are defined in the media-specific MIB for that
interface.  After invoking a test, the object ifTestResult
can be read to determine the outcome.  If an agent can not
perform the test, ifTestResult is set to so indicate.  The
object ifTestCode can be used to provide further test-
specific or interface-specific (or even enterprise-specific)
information concerning the outcome of the test.  Only one
test can be in progress on each interface at any one time.
If one test is in progress when another test is invoked, the
second test is rejected.  Some agents may reject a test when
a prior test is active on another interface.

Before starting a test, a manager-station must first obtain
'ownership' of the entry in the ifTestTable for the
interface to be tested.  This is accomplished with the
ifTestId and ifTestStatus objects as follows:

          try_again:
  get (ifTestId, ifTestStatus)
  while (ifTestStatus != notInUse)
      /*
       * Loop while a test is running or some other
       * manager is configuring a test.
       */
      short delay
      get (ifTestId, ifTestStatus)
  }

  /*
   * Is not being used right now -- let's compete
   * to see who gets it.
   */
  lock_value = ifTestId

  if ( set(ifTestId = lock_value, ifTestStatus = inUse,
           ifTestOwner = 'my-IP-address') == FAILURE)
      /*
       * Another manager got the ifTestEntry -- go
       * try again
       */
      goto try_again;

  /*
   * I have the lock
   */
  set up any test parameters.

  /*
   * This starts the test
   */
  set(ifTestType = test_to_run);

  wait for test completion by polling ifTestResult

  when test completes, agent sets ifTestResult
       agent also sets ifTestStatus = 'notInUse'

  retrieve any additional test results, and ifTestId

  if (ifTestId == lock_value+1) results are valid

A manager station first retrieves the value of the
appropriate ifTestId and ifTestStatus objects, periodically
repeating the retrieval if necessary, until the value of
ifTestStatus is 'notInUse'.  The manager station then tries
to set the same ifTestId object to the value it just
retrieved, the same ifTestStatus object to 'inUse', and the
corresponding ifTestOwner object to a value indicating
itself.  If the set operation succeeds then the manager has
obtained ownership of the ifTestEntry, and the value of the
ifTestId object is incremented by the agent (per the
semantics of TestAndIncr).  Failure of the set operation
indicates that some other manager has obtained ownership of
the ifTestEntry.

Once ownership is obtained, any test parameters can be
setup, and then the test is initiated by setting ifTestType.
On completion of the test, the agent sets ifTestStatus to
'notInUse'.  Once this occurs, the manager can retrieve the
results.  In the (rare) event that the invocation of tests
by two network managers were to overlap, then there would be
a possibility that the first test's results might be
overwritten by the second test's results prior to the first

results being read.  This unlikely circumstance ca
</pre>
</td>
</tr>
<tr><td class="label"><a name="ifTestEntry" />Row Description</td>
<td>
<pre>
An entry containing objects for invoking tests on an
interface.
</pre>
</td>
</tr>
  </table>

  <h4>ifTestTable Indexes:</h4>

<table>
<tr class="label"><th>Name</th><th>Type</th><th>Access</th><th>Description</th></tr>
  <tr>
  <td>
<a name="ifIndex" />
1
<br /><b>ifIndex</b>

</td><td>
  INTEGER32
      <br />Legal values:
        1 .. 2147483647
 <br>
 <a href="#InterfaceIndex">InterfaceIndex</a>

  </td><td>ReadOnly</td>
<td>
<p>
Note: this object is based on the <a href="#InterfaceIndex"> InterfaceIndex TEXTUAL-CONVENTION</a>.
</p>
<pre>
A unique value, greater than zero, for each interface.  It
is recommended that values are assigned contiguously
starting from 1.  The value for each interface sub-layer
must remain constant at least from one re-initialization of
the entity's network management system to the next re-
initialization.
</pre>
</td>
  </tr>
</table>

  <h4>Other ifTestTable Columns:</h4>
<table>
<tr class="label"><th>Name</th><th>Type</th><th>Access</th><th>Description</th></tr>
  <tr>
  <td class="deprecated">
<a name="ifTestId" />
1
<br /><b>ifTestId</b>

</td><td>
<font color="red">DEPRECATED</font><br />
  INTEGER
      <br />Legal values:
        0 .. 2147483647
 <br>
 <a href="#TestAndIncr">TestAndIncr</a>

  </td><td>ReadWrite</td>
<td>
<p>
Note: this object is based on the <a href="#TestAndIncr"> TestAndIncr TEXTUAL-CONVENTION</a>.
</p>
<pre>
This object identifies the current invocation of the
interface's test.
</pre>
</td>
  </tr>
  <tr>
  <td class="deprecated">
<a name="ifTestStatus" />
2
<br /><b>ifTestStatus</b>

</td><td>
<font color="red">DEPRECATED</font><br />
  INTEGER
      <table class="enum">
      <tr><th>Value</th><th>Label/Meaning</th></tr>
        <tr><td>1</td><td>notInUse</td></tr>
        <tr><td>2</td><td>inUse</td></tr>
      </table>

  </td><td>ReadWrite</td>
<td>
<pre>
This object indicates whether or not some manager currently
has the necessary 'ownership' required to invoke a test on
this interface.  A write to this object is only successful
when it changes its value from 'notInUse(1)' to 'inUse(2)'.
After completion of a test, the agent resets the value back
to 'notInUse(1)'.
</pre>
</td>
  </tr>
  <tr>
  <td class="deprecated">
<a name="ifTestType" />
3
<br /><b>ifTestType</b>

</td><td>
<font color="red">DEPRECATED</font><br />
  OBJECTID
 <br>
 <a href="#AutonomousType">AutonomousType</a>

  </td><td>ReadWrite</td>
<td>
<p>
Note: this object is based on the <a href="#AutonomousType"> AutonomousType TEXTUAL-CONVENTION</a>.
</p>
<pre>
A control variable used to start and stop operator-
initiated interface tests.  Most OBJECT IDENTIFIER values
assigned to tests are defined elsewhere, in association with
specific types of interface.  However, this document assigns
a value for a full-duplex loopback test, and defines the
special meanings of the subject identifier:

    noTest  OBJECT IDENTIFIER ::= { 0 0 }

When the value noTest is written to this object, no action
is taken unless a test is in progress, in which case the
test is aborted.  Writing any other value to this object is

only valid when no test is currently in progress, in which
case the indicated test is initiated.

When read, this object always returns the most recent value
that ifTestType was set to.  If it has not been set since
the last initialization of the network management subsystem
on the agent, a value of noTest is returned.
</pre>
</td>
  </tr>
  <tr>
  <td class="deprecated">
<a name="ifTestResult" />
4
<br /><b>ifTestResult</b>

</td><td>
<font color="red">DEPRECATED</font><br />
  INTEGER
      <table class="enum">
      <tr><th>Value</th><th>Label/Meaning</th></tr>
        <tr><td>1</td><td>none</td></tr>
        <tr><td>2</td><td>success</td></tr>
        <tr><td>3</td><td>inProgress</td></tr>
        <tr><td>4</td><td>notSupported</td></tr>
        <tr><td>5</td><td>unAbleToRun</td></tr>
        <tr><td>6</td><td>aborted</td></tr>
        <tr><td>7</td><td>failed</td></tr>
      </table>

  </td><td>ReadOnly</td>
<td>
<pre>
This object contains the result of the most recently
requested test, or the value none(1) if no tests have been
requested since the last reset.  Note that this facility
provides no provision for saving the results of one test
when starting another, as could be required if used by
multiple managers concurrently.
</pre>
</td>
  </tr>
  <tr>
  <td class="deprecated">
<a name="ifTestCode" />
5
<br /><b>ifTestCode</b>

</td><td>
<font color="red">DEPRECATED</font><br />
  OBJECTID

  </td><td>ReadOnly</td>
<td>
<pre>
This object contains a code which contains more specific
information on the test result, for example an error-code
after a failed test.  Error codes and other values this
object may take are specific to the type of interface and/or
test.  The value may have the semantics of either the
AutonomousType or InstancePointer textual conventions as
defined in RFC 2579.  The identifier:

    testCodeUnknown  OBJECT IDENTIFIER ::= { 0 0 }

is defined for use if no additional result code is
available.
</pre>
</td>
  </tr>
  <tr>
  <td class="deprecated">
<a name="ifTestOwner" />
6
<br /><b>ifTestOwner</b>

</td><td>
<font color="red">DEPRECATED</font><br />
  OCTETSTR
      <br />Legal Lengths:
        0 .. 255
 <br>
 <a href="#OwnerString">OwnerString</a>

  </td><td>ReadWrite</td>
<td>
<p>
Note: this object is based on the <a href="#OwnerString"> OwnerString TEXTUAL-CONVENTION</a>.
</p>
<pre>
The entity which currently has the 'ownership' required to
invoke a test on this interface.
</pre>
</td>
  </tr>
</table>
</ul>

<br>
  </table>
<hr />
<a name="notifications" />
<h2>NOTIFICATIONS</h2>
<ul>
<p>
</ul>


<br>
<hr />
<a name="textconventions" />
<h2>TEXTUAL CONVENTIONS</h2>
<ul>
<p>
These TEXTUAL-CONVENTIONS are used in other parts of the document
above.  They are SNMP's way of defining a datatype that is used
repeatedly by other MIB objects.  Any implementation implementing
objects that use one of these definitions must follow its DESCRIPTION
clause as well as the DESCRIPTION clause of the object itself.
</p>
<table><tr class="label"><th>Name</th><th>Type</th><th>Description</th></tr>
<tr><td><a name="TestAndIncr">TestAndIncr</td><td>INTEGER</td><td><pre>Represents integer-valued information used for atomic
operations.  When the management protocol is used to specify
that an object instance having this syntax is to be
modified, the new value supplied via the management protocol
must precisely match the value presently held by the
instance.  If not, the management protocol set operation
fails with an error of `inconsistentValue'.  Otherwise, if
the current value is the maximum value of 2^31-1 (2147483647
decimal), then the value held by the instance is wrapped to
zero; otherwise, the value held by the instance is
incremented by one.  (Note that regardless of whether the
management protocol set operation succeeds, the variable-
binding in the request and response PDUs are identical.)

The value of the ACCESS clause for objects having this
syntax is either `read-write' or `read-create'.  When an
instance of a columnar object having this syntax is created,
any value may be supplied via the management protocol.

When the network management portion of the system is re-
initialized, the value of every object instance having this
syntax must either be incremented from its value prior to
the re-initialization, or (if the value prior to the re-
initialization is unknown) be set to a pseudo-randomly
generated value.</pre></td></tr>
<tr><td><a name="TimeStamp">TimeStamp</td><td>TICKS</td><td><pre>The value of the sysUpTime object at which a specific
occurrence happened.  The specific occurrence must be

defined in the description of any object defined using this
type.

If sysUpTime is reset to zero as a result of a re-
initialization of the network management (sub)system, then
the values of all TimeStamp objects are also reset.
However, after approximately 497 days without a re-
initialization, the sysUpTime object will reach 2^^32-1 and
then increment around to zero; in this case, existing values
of TimeStamp objects do not change.  This can lead to
ambiguities in the value of TimeStamp objects.</pre></td></tr>
<tr><td><a name="InterfaceIndex">InterfaceIndex</td><td>INTEGER32</td><td><pre>A unique value, greater than zero, for each interface or
interface sub-layer in the managed system.  It is
recommended that values are assigned contiguously starting
from 1.  The value for each interface sub-layer must remain
constant at least from one re-initialization of the entity's
network management system to the next re-initialization.</pre></td></tr>
<tr><td><a name="AutonomousType">AutonomousType</td><td>OBJECTID</td><td><pre>Represents an independently extensible type identification
value.  It may, for example, indicate a particular sub-tree
with further MIB definitions, or define a particular type of
protocol or hardware.</pre></td></tr>
<tr><td><a name="DisplayString">DisplayString</td><td>OCTETSTR</td><td><pre>Represents textual information taken from the NVT ASCII
character set, as defined in pages 4, 10-11 of RFC 854.
To summarize RFC 854, the NVT ASCII repertoire specifies:
  - the use of character codes 0-127 (decimal)
  - the graphics characters (32-126) are interpreted as
                US ASCII
  - NUL, LF, CR, BEL, BS, HT, VT and FF have the special
                meanings specified in RFC 854
  - the other 25 codes have no standard interpretation
  - the sequence 'CR LF' means newline
  - the sequence 'CR NUL' means carriage-return
  - an 'LF' not preceded by a 'CR' means moving to the
                same column on the next line.
  - the sequence 'CR x' for any x other than LF or NUL is
                illegal.  (Note that this also means that a string may
                end with either 'CR LF' or 'CR NUL', but not with CR.)
Any object defined using this syntax may not exceed 255
            characters in length.</pre></td></tr>
<tr><td><a name="PhysAddress">PhysAddress</td><td>OCTETSTR</td><td><pre>Represents media- or physical-level addresses.</pre></td></tr>
<tr><td><a name="OwnerString">OwnerString</td><td>OCTETSTR</td><td><pre>This data type is used to model an administratively
assigned name of the owner of a resource.  This information
is taken from the NVT ASCII character set.  It is suggested
that this name contain one or more of the following: ASCII
form of the manager station's transport address, management
station name (e.g., domain name), network management
personnel's name, location, or phone number.  In some cases
the agent itself will be the owner of an entry.  In these
cases, this string shall be set to a string starting with
'agent'.</pre></td></tr>
<tr><td><a name="TruthValue">TruthValue</td><td>INTEGER<table class="enums"><tr><th>Value</th><th>Label/Meaning</th></tr><tr><td>1</td><td>true</td></tr><tr><td>2</td><td>false</td></tr></table></td><td><pre>Represents a boolean value.</pre></td></tr>
<tr><td><a name="RowStatus">RowStatus</td><td>INTEGER<table class="enums"><tr><th>Value</th><th>Label/Meaning</th></tr><tr><td>1</td><td>active</td></tr><tr><td>2</td><td>notInService</td></tr><tr><td>3</td><td>notReady</td></tr><tr><td>4</td><td>createAndGo</td></tr><tr><td>5</td><td>createAndWait</td></tr><tr><td>6</td><td>destroy</td></tr></table></td><td><pre>The RowStatus textual convention is used to manage the
creation and deletion of conceptual rows, and is used as the
value of the SYNTAX clause for the status column of a
conceptual row (as described in Section 7.7.1 of [2].)

The status column has six defined values:

     - `active', which indicates that the conceptual row is
     available for use by the managed device;

     - `notInService', which indicates that the conceptual
     row exists in the agent, but is unavailable for use by
     the managed device (see NOTE below); 'notInService' has
     no implication regarding the internal consistency of
     the row, availability of resources, or consistency with
     the current state of the managed device;

     - `notReady', which indicates that the conceptual row
     exists in the agent, but is missing information
     necessary in order to be available for use by the
     managed device (i.e., one or more required columns in
     the conceptual row have not been instanciated);

     - `createAndGo', which is supplied by a management
     station wishing to create a new instance of a
     conceptual row and to have its status automatically set
     to active, making it available for use by the managed
     device;

     - `createAndWait', which is supplied by a management
     station wishing to create a new instance of a
     conceptual row (but not make it available for use by
     the managed device); and,
     - `destroy', which is supplied by a management station
     wishing to delete all of the instances associated with
     an existing conceptual row.

Whereas five of the six values (all except `notReady') may
be specified in a management protocol set operation, only
three values will be returned in response to a management
protocol retrieval operation:  `notReady', `notInService' or
`active'.  That is, when queried, an existing conceptual row
has only three states:  it is either available for use by
the managed device (the status column has value `active');
it is not available for use by the managed device, though
the agent has sufficient information to attempt to make it
so (the status column has value `notInService'); or, it is
not available for use by the managed device, and an attempt
to make it so would fail because the agent has insufficient
information (the state column has value `notReady').

                         NOTE WELL

     This textual convention may be used for a MIB table,
     irrespective of whether the values of that table's
     conceptual rows are able to be modified while it is
     active, or whether its conceptual rows must be taken
     out of service in order to be modified.  That is, it is
     the responsibility of the DESCRIPTION clause of the
     status column to specify whether the status column must
     not be `active' in order for the value of some other
     column of the same conceptual row to be modified.  If
     such a specification is made, affected columns may be
     changed by an SNMP set PDU if the RowStatus would not
     be equal to `active' either immediately before or after
     processing the PDU.  In other words, if the PDU also
     contained a varbind that would change the RowStatus
     value, the column in question may be changed if the
     RowStatus was not equal to `active' as the PDU was
     received, or if the varbind sets the status</pre></td></tr>
<tr><td><a name="InterfaceIndexOrZero">InterfaceIndexOrZero</td><td>INTEGER32</td><td><pre>This textual convention is an extension of the
InterfaceIndex convention.  The latter defines a greater
than zero value used to identify an interface or interface
sub-layer in the managed system.  This extension permits the
additional value of zero.  the value zero is object-specific
and must therefore be defined as part of the description of
any object which uses this syntax.  Examples of the usage of
zero might include situations where interface was unknown,
or when none or all interfaces need to be referenced.</pre></td></tr>
</table></ul>

<a name="treeview" />
<h2>TREE VIEW</h2>
<p>Tree view generated by running: <b>snmptranslate -Tp IF-MIB::ifMIBObjects</b></p>
<pre>
+--<a href="#ifMIBObjects">ifMIBObjects</a>(1)
   |
   +--<a href="#ifXTable">ifXTable</a>(1)
   |  |
   |  +--<a href="#ifXEntry">ifXEntry</a>(1)
   |     |
   |     +-- -R-- String    <a href="#ifName">ifName</a>(1)
   |     |        Textual Convention: <a href="#DisplayString">DisplayString</a>
   |     |        Size: 0..255
   |     +-- -R-- Counter   <a href="#ifInMulticastPkts">ifInMulticastPkts</a>(2)
   |     +-- -R-- Counter   <a href="#ifInBroadcastPkts">ifInBroadcastPkts</a>(3)
   |     +-- -R-- Counter   <a href="#ifOutMulticastPkts">ifOutMulticastPkts</a>(4)
   |     +-- -R-- Counter   <a href="#ifOutBroadcastPkts">ifOutBroadcastPkts</a>(5)
   |     +-- -R-- Counter64 <a href="#ifHCInOctets">ifHCInOctets</a>(6)
   |     +-- -R-- Counter64 <a href="#ifHCInUcastPkts">ifHCInUcastPkts</a>(7)
   |     +-- -R-- Counter64 <a href="#ifHCInMulticastPkts">ifHCInMulticastPkts</a>(8)
   |     +-- -R-- Counter64 <a href="#ifHCInBroadcastPkts">ifHCInBroadcastPkts</a>(9)
   |     +-- -R-- Counter64 <a href="#ifHCOutOctets">ifHCOutOctets</a>(10)
   |     +-- -R-- Counter64 <a href="#ifHCOutUcastPkts">ifHCOutUcastPkts</a>(11)
   |     +-- -R-- Counter64 <a href="#ifHCOutMulticastPkts">ifHCOutMulticastPkts</a>(12)
   |     +-- -R-- Counter64 <a href="#ifHCOutBroadcastPkts">ifHCOutBroadcastPkts</a>(13)
   |     +-- -RW- EnumVal   <a href="#ifLinkUpDownTrapEnable">ifLinkUpDownTrapEnable</a>(14)
   |     |        Values: enabled(1), disabled(2)
   |     +-- -R-- Gauge     <a href="#ifHighSpeed">ifHighSpeed</a>(15)
   |     +-- -RW- EnumVal   <a href="#ifPromiscuousMode">ifPromiscuousMode</a>(16)
   |     |        Textual Convention: <a href="#TruthValue">TruthValue</a>
   |     |        Values: true(1), false(2)
   |     +-- -R-- EnumVal   <a href="#ifConnectorPresent">ifConnectorPresent</a>(17)
   |     |        Textual Convention: <a href="#TruthValue">TruthValue</a>
   |     |        Values: true(1), false(2)
   |     +-- -RW- String    <a href="#ifAlias">ifAlias</a>(18)
   |     |        Textual Convention: <a href="#DisplayString">DisplayString</a>
   |     |        Size: 0..64
   |     +-- -R-- TimeTicks <a href="#ifCounterDiscontinuityTime">ifCounterDiscontinuityTime</a>(19)
   |              Textual Convention: <a href="#TimeStamp">TimeStamp</a>
   |
   +--<a href="#ifStackTable">ifStackTable</a>(2)
   |  |
   |  +--<a href="#ifStackEntry">ifStackEntry</a>(1)
   |     |  Index: ifStackHigherLayer, ifStackLowerLayer
   |     |
   |     +-- ---- Integer32 <a href="#ifStackHigherLayer">ifStackHigherLayer</a>(1)
   |     |        Textual Convention: <a href="#InterfaceIndexOrZero">InterfaceIndexOrZero</a>
   |     |        Range: 0..2147483647
   |     +-- ---- Integer32 <a href="#ifStackLowerLayer">ifStackLowerLayer</a>(2)
   |     |        Textual Convention: <a href="#InterfaceIndexOrZero">InterfaceIndexOrZero</a>
   |     |        Range: 0..2147483647
   |     +-- CR-- EnumVal   <a href="#ifStackStatus">ifStackStatus</a>(3)
   |              Textual Convention: <a href="#RowStatus">RowStatus</a>
   |              Values: active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
   |
   +--<a href="#ifTestTable">ifTestTable</a>(3)
   |  |
   |  +--<a href="#ifTestEntry">ifTestEntry</a>(1)
   |     |
   |     +-- -RW- INTEGER   <a href="#ifTestId">ifTestId</a>(1)
   |     |        Textual Convention: <a href="#TestAndIncr">TestAndIncr</a>
   |     |        Range: 0..2147483647
   |     +-- -RW- EnumVal   <a href="#ifTestStatus">ifTestStatus</a>(2)
   |     |        Values: notInUse(1), inUse(2)
   |     +-- -RW- ObjID     <a href="#ifTestType">ifTestType</a>(3)
   |     |        Textual Convention: <a href="#AutonomousType">AutonomousType</a>
   |     +-- -R-- EnumVal   <a href="#ifTestResult">ifTestResult</a>(4)
   |     |        Values: none(1), success(2), inProgress(3), notSupported(4), unAbleToRun(5), aborted(6), failed(7)
   |     +-- -R-- ObjID     <a href="#ifTestCode">ifTestCode</a>(5)
   |     +-- -RW- String    <a href="#ifTestOwner">ifTestOwner</a>(6)
   |              Textual Convention: <a href="#OwnerString">OwnerString</a>
   |              Size: 0..255
   |
   +--<a href="#ifRcvAddressTable">ifRcvAddressTable</a>(4)
   |  |
   |  +--<a href="#ifRcvAddressEntry">ifRcvAddressEntry</a>(1)
   |     |  Index: ifIndex, ifRcvAddressAddress
   |     |
   |     +-- ---- String    <a href="#ifRcvAddressAddress">ifRcvAddressAddress</a>(1)
   |     |        Textual Convention: <a href="#PhysAddress">PhysAddress</a>
   |     +-- CR-- EnumVal   <a href="#ifRcvAddressStatus">ifRcvAddressStatus</a>(2)
   |     |        Textual Convention: <a href="#RowStatus">RowStatus</a>
   |     |        Values: active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
   |     +-- CR-- EnumVal   <a href="#ifRcvAddressType">ifRcvAddressType</a>(3)
   |              Values: other(1), volatile(2), nonVolatile(3)
   |
   +-- -R-- TimeTicks <a href="#ifTableLastChange">ifTableLastChange</a>(5)
   +-- -R-- TimeTicks <a href="#ifStackLastChange">ifStackLastChange</a>(6)
</pre>
<!-- CONTENT END -->